
[[crossCuting]]
= Préoccupations transverses de modélisation

//-----------------------------------------------
ifndef::final[]
.Commentaire
[CAUTION]
====
*****
Traçabilité, allocation etc.
*****
====
//-----------------------------------------------
endif::final[]

On abordera :

- Les <<org,aspects organisationnels>>
- La <<trace,traçabilité des exigences>>
- Les <<allocation,mécanismes d'allocation>>
- Le <<paramt,diagramme paramétrique>> (aspects transveres)

[[org]]
//---------------------------------------------------------------------------------
== Organisation
//---------------------------------------------------------------------------------

ifdef::backend-pdf[[cols="h,4*",options="header"]]
ifndef::backend-pdf[[cols="h,4*",options="header",width="90%"]]
|======================
|					| {Requirements} 	| {Structure}	| {Behavior} 	| {Crosscutting}
| {organisation}	|					|        		|		| {here}
| {analysis}		|					|        		|				|
| {design}			|					|        		|				|
| {implementation}	|					|        		|				|
|======================

=== Fondements

On abordera :

- Le _Package Diagram_
- Les différent types de _packages_
- Les organisations possibles
- La notion de _Namespaces_
- Les _Dependencies_

[[package]]
=== Le _Package Diagram_

Le diagramme de paquetage permet de représenter l'organisation des modèles en paquetages.

ifndef::backend-pdf[]
* Il est identique à {uml}, et classique pour les développeurs (java notamment)
* Il permet d'organiser les modèles en créant un espace de nommage (cf <<namespace>>)
endif::backend-pdf[]
ifdef::backend-pdf[]
Ce diagramme est identique à celui d'{uml}, et le concept de paquetage (_package_) est classique pour les développeurs (java notamment).
Il permet d'organiser les modèles en créant un espace de nommage (cf <<namespace>>).
endif::backend-pdf[]

=== Les différent types de _packages_

Il existe plusieurs types de _packages_ :

`models`::
	un _package_ "top-level" dans une hiérarchie de _packages_
`packages`::
	le type le plus classique : un ensemble d'éléments de modèles
`model librairies`::
	un _package_ prévu pour être réutilisé (importé) par d'autres éléments
`views`::
	un _package_ spécial pour représenter les points de vue

[TIP]
====
Un point de vue (_viewpoint_) est utilisé pour matérialiser une perspective particulière de modélisation.
Il possède des propriétés standardisés (_concerns_, _language_, _purpose_, etc.) et permet d'indiquer qu'une
vue (un _packetage_ particulier, stéréotypé `<<view>>`) est conforme (dépendance `<<conform>>`) à un point de vue.
====

[[organisation]]
=== Les organisations possibles

Les modèles peuvent être organisés selon toutes sortes de considération :

- par hiérarchie "système" (e.g., entreprise, système, composant, ...)
- par types de diagrammes (e.g., besoins, structure, comportements, ...)
- par cycle de vie (e.g., analyse, conception, ...)
- par équipes (e.g., architectes, <<IPT>>, ...)
- par points de vue (e.g., sécurité, performance, ...)
- etc.

.Exemple d'organisation simple
image::pkg-organisation2.png[width="70%",scaledwidth="80%"]

.Représentation de cette organisation dans un outil
image::pkg-organisation-modelview.png[width="40%",scaledwidth="40%"]

[[namespace]]
=== La notion de _Namespaces_

Un _package_ permet de créer un espace de nommage pour tous les éléments qu'il contient.
Ainsi, dans un _package_, on n'a pas à se soucier des noms des éléments.
Même si d'autres utilisent les mêmes noms, il n'y aura pas ambiguïté.

.Définition : _Namespace_ (OMG SysML v1.4, p. 21)
[NOTE]
====
_The package defines a namespace for the packageable elements._
====

Pour éviter toute ambiguïté, on peut utiliser pour les éléments de modèles leur nom complet (_Qualified name_),
c'est à dire le nom de l'élément préfixé par son (ou ses) _package(s)_
(e.g., `Structure::Products::Clock`).

[TIP]
====
Dans les outils {sysml}, il faut souvent demander explicitement à voir les noms complets (_Qualified names_)
des éléments (la plupart du temps dans les options graphiques).

====

=== Les dépendances

Un certain nombre de dépendances peuvent exister entre des éléments de _package_
ou entre les _packages_ eux-mêmes :

_Dependency_::
	une dépendance "générale", non précisée,
	représentée par une simple flèche pointillée +----->+
_Use_::
	l'élément "utilise" celui à l'autre bout de la flèche (un type par exemple),
	représentée par le stéréotype `<<use>>`
_Refine_::
	l'élément est un raffinage (plus détaillé) de celui à l'autre bout de la flèche,
	représentée par le stéréotype `<<refine>>`
_Realization_::
	l'élément est une "réalisation" (implémentation) de celui à l'autre bout de la flèche,
	représentée par le stéréotype `<<realize>>`
_Allocation_::
	l'élément (e.g., une activité ou un _requirement_) est "alloué" sur celui à l'autre
  bout de la flèche (un `block` la plupart du temps),
	représentée par le stéréotype `<<allocate>>`

[[trace]]
//---------------------------------------------------------------------------------
== La traçabilité des exigences

Nous avons vu déjà un certain nombre de mécanismes {sysml} qui permettent de tracer les exigences.
Nous les regroupons ici dans une matrice spécifique (qui se lit dans le sens des relations, par exemple un élément de structure comme un bloc `\<<satisfy>>` une exigence).

.Traçabilité
ifdef::book[[cols="h,3*",options="header"]]
ifndef::book[[cols="h,3*",options="header",width="50%"]]
|======================
|					| {Requirements} 							| {Structure}	| {Behavior}
| {Requirements}	| `<<deriveRqt>>`, `<<refine>>`, `<<copy>>` |    			|
| {Structure}		| `<<allocate>>`, `<<satisfy>>`				| 				| `<<allocate>>`
| {Behavior}		| `<<refine>>`								|				|
|======================

Comme indiqué dans le tableau ci-dessus, en général, le lien de raffinement est utilisé entre une exigence et un élément comportemental (état, activité, `{uc}`, etc.) tandis que l'allocation concerne principalement les éléments de structures.

[red]#XXX Mettre un exemple avec tous ces liens. XXX#

[[allocation]]
//---------------------------------------------------------------------------------
== Les mécanismes d'allocation

Un mécanisme nouveau en {sysml} et important pour l{is} est le mécanisme d'*allocation*.
Il permet de préciser quel élément conceptuel (comme un comportement ou une activité) est alloué sur quel élément physique.
Il est possible d'exprimer cette allocation de plusieurs manières.

[red]#XXX ToDO XXX#

- Parler du `\<<AllocatedTo>>`, compartiments des blocs et autres annotations.
- Parler des zones d'allocation dans les machines à états où les diagrammes d'activités par exemple.
- Parler des `\<<allocate>>`.

[[paramt]]
//---------------------------------------------------------------------------------
== Le diagramme paramétrique

C'est une forme particulière d'_Internal Block Definition_ (cf. <<param>>).
On y retrouve les contraintes, déjà vues (cf. <<contraintes>>), mais cette fois-ci on a la représentation graphique des liens entre les données.

.Exemple de diagramme paramétrique
image::param.png[width="90%",scaledwidth=50%]

[NOTE]
====
Il est regrettable que ce diagramme soit le moins utilisé (cf. <<OMG2009>>).

.Diagrammes les plus utilisés (tiré de <<OMG2009>>)
image::survey4.png[link="http://www.omgsysml.org/SysML_2009_RFI_Response_Summary-bone-cloutier.pdf",width="80%",scaledwidth=50%]
====

[NOTE]
====
Certaines approches (cf. <<MeDICIS>>) utilisent des feuilles excel pour traduire les diagrammes paramétriques et contrôler l'impact des changements de valeurs de tel ou tel paramètre.
====

== {resume}
{sysml} propose un certain nombre de mécanismes pour organiser les différents modèles,
tirés pour la plupart d'{uml}. Ces mécanismes seront plus faciles à comprendre au travers
de leur utilisation concrète dans la suite.

.Organisation
ifdef::backend-pdf[[cols="h,4*",options="header"]]
ifndef::backend-pdf[[cols="h,4*",options="header",width="90%"]]
|======================
|						| {Requirements} 	| {Structure}	| {Behavior} 	| {Crosscutting}
| {organisation}	| `package`			| `package`		| `package`		| `dependencies`
| ...					|					|        		|				|
|======================

== {revisions}

. Quels sont les 5 types de dépendances entre _packageable elements_ ?
. À quoi cela peut-il servir de définir les dépendances (donnez des exemples concrets) ?
. Quelles sont les différences entre `\<<satisfy>>` et `\<<allocate>>` ?
. Pourquoi est-il important de relier un _use case_ à au moins un _requirement_ ?
. L'inverse est-il aussi important ?

ifdef::correction[]

== Éléments de réponses :

. Quelles sont les différences entre `\<<satisfy>>` et `\<<allocate>>` ?
La satisfaction concerne une propriété (d'une solution vis à vis d'un problème) quand l'allocation permet de rajouter un information sur qui fait quoi.
. Pourquoi est-il important de relier un _use case_ à au moins un _requirement_ ?
Sinon on peut se demander s'il s'agit vraiment d'une utilisation du système qui nous concerne (une exigence a-t'elle été oubliée?).
. L'inverse est-il aussi important ?
Encore plus je dirais, au sens où une exigence n'est couverte par aucune utilisation du système (cela peut arriver lors d'une exigence non satisfiable!)

endif::correction[]
