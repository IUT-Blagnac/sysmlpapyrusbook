
[[Intro]]
= Introduction

//-----------------------------------------------
ifndef::final[]
.Commentaire
[CAUTION]
====
*****
Aborder le fait qu'il y a bcp de méthodes qui existent et que ici on est agnostique.
En revanche, on en choisit une (simplifié) pour l'illustration pour la mise en pratique de SysML dans Papyrus.
*****
====
//-----------------------------------------------
endif::final[]

SysML est un langage de modélisation, certains diraient une notation.
La principale difficulté, avec SysML, c'est que cette notation n'est associée a aucune méthode en particulier, ni aucun outil en particulier (cf. <<sysmlprfc>>).
Il s'agit là d'une volonté délibérée des concepteurs, l'{OMG} et l'{INCOSE}, pour permettre la plus grande adoption de la notation dans les entreprises.
Il vous sera donc possible d'appliquer votre propre démarche, votre propre processus interne de développement.
Contrairement à l'outil {capella} par exemple, fortement couplé à la méthode {Arcadia}, l'outil {papyrus} n'impose aucune démarche particulière.
Nous allons aborder <<methods,en fin de ce chapitre>> les processus connus et courants en ingénierie système généralement associés à SysML.
Pour les besoins de ce livre nous avons retenu la démarche préconisée par Friedenthal dans <<Friedenthal2016>>.

.Langages, méthodes et outils : 3 piliers complémentaires (inspiré par http://www.prfc.fr/[prfc Roques])
image::SysML-PRFC.svg[width=50%,scaledwidth=50%]

== Pourquoi et quoi modéliser

//-----------------------------------------------
ifndef::final[]
.Commentaire
[CAUTION]
====
*****
Parler de l'importance de modéliser, des points forts du MBSE, etc.
Différences entre diagrammes, tables, vues, etc.
Aborder l'importance de la différence entre les éléments de modèles et leur représentation.
Aborder la "philosophie" de Papyrus en la matière.
*****
====
//-----------------------------------------------
endif::final[]

=== Pourquoi modéliser

[quote, Marvin Minski, "Matter, mind, and models (Semantic Information Processing 1968)""]
____________________________________________________________________
Pour un observateur A, M est un *modèle* de l’objet O, si M aide A à répondre aux
questions qu’il se pose sur O
____________________________________________________________________

Il n'est pas dans les objectifs de ce livre d'explorer cette vaste question (voir
  <<Jézéquel>> ou <<Cabot>>), mais disons simplement que nous considérons la définition
  ci-dessus comme essentielle.
Les modèles permettent de communiquer (entre personnes, entre outils) et d'appréhender la complexité des véritables systèmes en développement.

=== Différence entre modèle et dessin

{SysML} n'est pas une palette de dessins et d'éléments de base servant à faire des diagrammes.
Il existe une représentation graphique des éléments modélisés en {SysML}.
Elle est importante car elle permet de communiquer visuellement sur le système en développement, mais du point de vue du concepteur, c'est *le modèle* qui importe le plus.

C'est pourquoi nous vous recommandons de ne jamais "dessiner" des diagrammes {SysML} footnote:[Sauf bien sûr au brouillon ou sur un tableau, notamment quand on travaille en équipe.], mais d'utiliser des outils dédiés comme {Papyrus}.
Ils respectent en général la norme {norme} (bien qu'il faille se méfier).

[NOTE]
====
Notez que la norme permet de faire des adaptations graphiques (cf. la discussion http://www.realtimeatwork.com/2011/08/is-sysml-too-abstract/).
====

// Merci à Raphaël Faudou pour cette partie

Un des intérêts de la modélisation est de faciliter la communication, notamment au travers des diagrammes et leur aspect graphique et synthétique.
Un dessin est donc un plus par rapport à du texte. Néanmoins, il ne faut pas se contenter d'un simple dessin pour au moins deux raisons importantes :

- un dessin n'est pas assez formel (comment être sûr d'avoir correctement utilisé tel ou tel symbole) ;
- il est impossible d'assurer la cohérence globale des modèles dans le cas d'un dessin.

Un modèle est une sorte de base de donnée qui regroupe des éléments issues de différents points de vue (saisis le plus
souvent au travers de diagrammes). Un diagramme est une vue partielle du modèle (donc incomplète).
Le modèle est la vraie plus value car il va permettre de détecter les incohérences sur les exigences, les problèmes de complétude,
lancer des analyses, faire des transformations vers d'autres langages ou formats, etc.
Par exemple dans un outil de modélisation il y a une grande différence entre supprimer un élément d'un diagramme (on parlera alors de "masquer" un élément d'un diagramme) et supprimer un élément de modèle (ce qui aura pour effet de supprimer cet élément de tous les diagrammes où il était présent).

//=== Quoi modéliser

[[methods]]
== Démarches et méthodes de développement

Ce livre n'est pas un livre sur l'ingénierie système.
Il ne s'agit donc pas pour nous de rappeler les grandes démarches de développement de système.
Nous renvoyons pour cela le lecteur aux grands classiques (xxx,yyy).

Références sur les méthodos : <<Estefan>>, <<Ramos>>, <<Dickerson>>,
CESAME, Arcadia, SEBOK, OOSE, Tim Wilkiens, CORE (EFFB), Merise?

[[Matrice]]
== Matrice des concepts

//-----------------------------------------------
ifndef::final[]
.Commentaire
[CAUTION]
====
*****
À voir si on garde pour pas cette idée icon:smile-o[]
*****
====
//-----------------------------------------------
endif::final[]

La matrice qui nous servira de "carte de base" pour placer les activités
ou les modèles, sera celle-ci :

include::matrice-base.asc[]

Cette matrice permet de situer les différents éléments qui seront vus dans ce cours dans un cadre utile pour comparer ces éléments les uns aux autres.
Nous vous conseillons de vous faire votre propre matrice.
L'essentiel est de toujours bien se représenter les différents éléments qu'on aborde dans une carte mentale précise. Cela permet une meilleure mémorisation.

=== Points de vue

Dans un axe horizontal, nous avons différencié quatre grands points de vue :

{Requirements}::
Les exigences et leur prises en compte sont un éléments critique pour le
  succès du développement de tout système.
  Sans explorer l'ensemble des activités d'ingénierie système (ce qui
  nécessiterait tout un volume du type de <<reqs>>) nous insisterons sur cet aspect.

{Structure}::
La description de l'architecture et des éléments constitutifs du système, avec les blocs, leurs relations, organisations internes, etc. constituera un point de vue important.
C'est souvent la partie de modélisation qui pose le moins de problème aux débutants.

{Behavior}::
Le comportement d'un système est du point de vue de l'utilisateur final beaucoup plus important que la structure elle-même.
C'est la partie qu'il est la plus à même d'exprimer, de comprendre (via les modèles) et de valider.
Nous distinguons dans ce livre le comportement global (du système) du comportement local (des éléments constitutifs).

{Crosscutting}::
Un certains nombre de concepts sont transverses aux trois points de vue précédents.
Il s'agira principalement de parler de cohérence ou de traçabilité entre les phases de développement ou entre les points de vue.


Ces différents points de vue ne doivent pas être confondus avec les différentes phases de développement (cf. <<devphase, paragraphe suivant>>).
Ils sont plutôt à rapprocher de la notion de préoccupation.
C'est ainsi que nous avons choisi de distinguer trois points de vue
qui se retrouvent souvent en modélisation : le point de vue des exigences qui permet de se focaliser sur les besoins des clients ;
le point de vue structurel qui permet de se focaliser sur les différents composants du système ;
et le point de vue comportemental qui permet de se focaliser sur le comportement global et local.
Ces trois points de vue n'étant pas indépendants les uns des autres, nous avons intégré un quatrième point de vue transversal.

[[devphase]]
=== Phase de développement

Dans un axe vertical, nous avons différencié quatre grandes phases du cycle de vie du développement :

{organisation}::
Une étape indépendante du type de cycle de développement envisagé (en V, agile, etc.) mais qui concerne la mise en place
d'un cadre de travail qui permette un développement de qualité (outils, éditeurs, gestionnaire de version, de tâches, etc.).

{analysis}::
Cette phase vise plutôt à examiner le domaine du problème. Elle se focalise sur les cahiers des charges et les exigences.
	L'analyse débouche sur un dossier d'analyse qui décrit les grandes lignes (cas d'utilisation, architecture principale) du système.

{design}::
Cette phase vise plutôt à examiner le domaine de la solution. Elle débouche sur un dossier de conception qui décrit les détails
	conceptuels de la solution envisagée (structure détaillée, comportement, etc.)

{implementation}::
Cette phase traite des développements finaux (construction ou approvisionnement en matériel, développement de codes, etc.).

Il s'agit ici classiquement des grandes étapes de développement d'un système.
On pourrait être surpris par l'étape que nous avons appelé "{organisation}".
C'est une étape que nous considérons importante, particulièrement pour l'enseignement.
Avant toute activité de modélisation ou de même de développement, il convient en effet de s'organiser en termes de choix d'outils, choix d'environnement, etc.
Cette étape est souvent négligée par les étudiants.
C'est pour cela que nous avons décidé de faire figurer cette étape de manière explicite.
Bien sûr dans une organisation existante cette étape sera contrainte par les habitudes "maison".


== Organisation de ce livre

//-----------------------------------------------
ifndef::final[]
.Commentaire
[CAUTION]
====
*****
Décrire la suite...
*****
====
//-----------------------------------------------
endif::final[]

Suite à cette introduction, nous allons présenter l'étude de cas qui nous servira de "fil rouge" (chapitre <<etudeCas>>).
Nous donnons ensuite les instructions pour installer l'environnement minimal pour réaliser les exercices de ce livre (chapitre <<install>>).
Nous donnons ensuite un aperçu de tous les diagrammes {sysml}, pour que le lecteur ait une bonne vue d'ensemble et puisse faire les connexions nécessaires entre tous les diagrammes.
Ensuite... (chapitre <<methode>>).
Ensuite... (chapitre <<start>>).
Nous rentrons dans le détail avec les chapitres suivants.
Nous commençons par les exigences (chapitre <<reqs>>).
Nous poursuivons par l'utilisation du système (cas d'utilisation et interfaces, chapitre <<Usages>>).
Ensuite nous traitons des éléments structurels (chapitre <<archi>>) et
comportementaux (chapitre <<behavior>>).
Interaction... (chapitre <<interaction>>).
Préoccupations transveres... (chapitre <<crossCuting>>).
Nous terminons par différents aspects complémentaires (chapitre <<realLife>>).
Un certain nombres d'<<acro,annexes>> complètent le livre.
